package main

import "fmt"

func main() {
	slice1()

	slice2()

	slice3()

	map1()
}

func map1() {
	m := make(map[string]int, 3)
	// лет и капасити в данном случае не 3 тут 3 - это хинт для рантайма
	// чтобы он смог сразу проаллоцировать массив достаточного размера

	x := len(m)
	// тут 0, нет элементов

	m["Go"] = m["Go"]
	// правая часть m["Go"] - по сути забирает нулевое значение int,
	// то есть 0, а уже после присвоения в мапе будет 1 ключ "Go"
	// со значение 0

	y := len(m)
	// тут 1 получается

	println(x, y)

	// распечатаем мапу шобы убедиться
	for k, v := range m {
		fmt.Println("Key:", k, "Value:", v)
	}
}

func slice3() {
	// #SLICES 3
	var x = []int{2: 5, 6, 0: 7}

	// тут фишка в том что выражения 2: 5 и 0: 7 инициируют значения в слайсе
	// то есть только после них будет 7 0 5 0 ( 0 0 так как еще 2 в литерале)
	// а остальные расставятся по свободным местам после последнего инциированного
	// с индексом в литерале: 7 0 5 6

	fmt.Println(x)

	var y = []int{4: 5, 6, 2, 9, 0: 7}

	// вот тут будет 7 0 0 0 5 6 2 9

	fmt.Println(y)
}

func slice2() {
	// #SLICES 2
	var x = []string{"A", "B", "C"}

	for i, s := range x {
		print(i, s, ",")
		x[i+1] = "M"
		x = append(x, "Z")
		x[i+1] = "Z"

		// короче тут прикол в том что внутри области видимости for с первым аппендом
		// появляется другой x на который нам похуй, по факту в первой итерации меняется
		// B на M и все, дальше уже никак не аффектит
	}

	fmt.Println(x)

}

func slice1() {
	// #SLICES 1
	a := [...]int{0, 1, 2, 3}

	// [...] значит что размер массива будет равен тому сколько значение
	// просунуто в литерале

	x := a[:1]

	// в x бероется [0] из a

	y := a[2:]

	// в y берется [2, 3] из a

	x = append(x, y...)

	// x теперь будет [0, 2, 3] - но так как у них все еще общий подмассив
	// a, в a теперь будет [0, 2, 3, 3], а в y - [3, 3]

	x = append(x, y...)

	// в x теперь будет 0 2 3 3 3 потому что переиницализируется новый массив,
	// а в a останется 0 2 3 3

	fmt.Println(a, x)
}
